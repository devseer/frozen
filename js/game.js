// Generated by CoffeeScript 1.6.3
(function() {
  var Core, Engine, Event, Generate, Handle, Input, Item, Mob, Objects, Particle, Player, Tile, Timers, World, root;

  Core = (function() {
    function Core(canvas, bgm, sfx) {
      this.handle = new Handle(canvas, bgm, sfx);
      this.timers = new Timers();
      this.tile = new Tile();
      this.input = new Input();
      this.event = new Event();
      this.generate = new Generate();
    }

    return Core;

  })();

  Objects = (function() {
    Objects.prototype.list = [];

    function Objects(core) {
      this.list = [new World(core), new Player(core), new Mob(core), new Item(core), new Particle(core)];
    }

    return Objects;

  })();

  Event = (function() {
    Event.prototype.bound = {};

    function Event() {
      this.bound = {
        x: 0,
        y: 0
      };
    }

    Event.prototype.update = function() {};

    Event.prototype.apply = function(event) {
      return false;
    };

    Event.prototype.collision = function(pos) {
      return pos.x < 0 || pos.x > 31 || pos.y < 0 || pos.y > 31;
    };

    Event.prototype.updateBound = function(bound) {
      return this.bound = bound;
    };

    return Event;

  })();

  Generate = (function() {
    Generate.prototype.type = {
      particle: 'particle'
    };

    Generate.prototype.objects = {};

    function Generate() {}

    Generate.prototype.spawn = function(type, pos, direction) {
      return console.log('spawn ' + this.type[type]);
    };

    Generate.prototype.update = function(objects) {
      return this.objecs = objects;
    };

    return Generate;

  })();

  Handle = (function() {
    function Handle(canvas, bgm, sfx) {
      this.canvas = document.getElementById(canvas);
      this.context = this.canvas.getContext('2d');
      this.bgm = document.getElementById(bgm);
      this.sfx = document.getElementById(sfx);
    }

    Handle.prototype.update = function() {};

    Handle.prototype.clear = function() {
      this.context.fillStyle = 'rgb(0, 0, 0)';
      return this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    };

    return Handle;

  })();

  Input = (function() {
    Input.prototype.keys = [];

    Input.prototype.direction = {
      up: 82,
      down: 72,
      left: 83,
      right: 84
    };

    Input.prototype.action = {
      attack: 32
    };

    function Input(handle) {
      var i, k, _i;
      for (i = _i = 0; _i <= 255; i = ++_i) {
        this.keys.push(false);
      }
      k = this.keys;
      document.onkeydown = function(e) {
        return k[e.keyCode] = true;
      };
      document.onkeyup = function(e) {
        return k[e.keyCode] = false;
      };
    }

    Input.prototype.update = function() {};

    return Input;

  })();

  Tile = (function() {
    Tile.prototype.tile = {};

    Tile.prototype.viewport = {};

    Tile.prototype.offset = {};

    Tile.prototype.source = {
      iceworld: 'iceworld.png',
      mage: 'mage.png',
      snowball: 'snowball.png',
      snowman: 'snowman.png'
    };

    function Tile() {
      this.tile = {
        width: 16,
        height: 16
      };
      this.viewport = {
        width: 15,
        height: 15
      };
      this.offset = {
        x: 0,
        y: 0
      };
    }

    Tile.prototype.updateOffset = function(pos) {
      return this.offset = pos;
    };

    Tile.prototype.update = function() {};

    Tile.prototype.loadTileset = function(name) {
      var img;
      img = new Image();
      img.src = 'img/tile/' + this.source[name];
      return img;
    };

    Tile.prototype.loadSpriteset = function(name) {
      var img;
      img = new Image();
      img.src = 'img/sprite/' + this.source[name];
      return img;
    };

    return Tile;

  })();

  Timers = (function() {
    Timers.prototype.timestamp = 0;

    Timers.prototype.list = [];

    function Timers() {
      this.updateTime();
    }

    Timers.prototype.update = function() {
      var i, _results;
      this.updateTime();
      _results = [];
      for (i in this.list) {
        if (this.list[i].time < this.timestamp) {
          _results.push(this.executeTimer(this.list[i], i));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Timers.prototype.addTimer = function(interval, callback) {
      return this.list.push({
        interval: interval,
        time: this.timestamp + interval,
        callback: callback
      });
    };

    Timers.prototype.executeTimer = function(timer, index) {
      if (timer.callback()) {
        return this.renewTimer(timer);
      } else {
        return this.list.splice(index, 1);
      }
    };

    Timers.prototype.renewTimer = function(timer) {
      return timer.time = timer.interval + this.timestamp;
    };

    Timers.prototype.updateTime = function() {
      return this.timestamp = new Date().getTime();
    };

    return Timers;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  Engine = (function() {
    Engine.prototype.handle = {};

    Engine.prototype.core = {};

    Engine.prototype.objects = {};

    function Engine(canvas, bgm, sfx) {
      this.core = new Core(canvas, bgm, sfx);
      this.objects = new Objects(this.core);
      this.main(this);
    }

    Engine.prototype.update = function() {
      var i, _i, _len, _ref, _results;
      for (i in this.core) {
        this.core[i].update();
      }
      _ref = this.objects.list;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        _results.push(i.update(this.core));
      }
      return _results;
    };

    Engine.prototype.draw = function() {
      var i, _i, _len, _ref, _results;
      this.core.handle.clear();
      _ref = this.objects.list;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        _results.push(i.draw(this.core.handle.context));
      }
      return _results;
    };

    Engine.prototype.main = function(c) {
      var _this = this;
      c.update();
      c.draw();
      return requestAnimationFrame(function() {
        return _this.main(c);
      });
    };

    return Engine;

  })();

  if (!root.Game) {
    root.Game = Engine;
  }

  Item = (function() {
    function Item() {}

    Item.prototype.update = function(core) {};

    Item.prototype.draw = function(context) {};

    return Item;

  })();

  Mob = (function() {
    Mob.prototype.arr = [];

    Mob.prototype.image = {};

    Mob.prototype.offset = {};

    Mob.prototype.bound = {
      x: 32,
      y: 32
    };

    Mob.prototype.nextMove = false;

    function Mob(core) {
      var i, _i,
        _this = this;
      this.image = core.tile.loadSpriteset('snowman');
      for (i = _i = 0; _i <= 3; i = ++_i) {
        this.arr.push({
          hp: 5,
          pos: {
            x: 0,
            y: 0
          }
        });
      }
      core.timers.addTimer(200, function(nextMove) {
        _this.nextMove = nextMove;
        _this.nextMove = true;
        return true;
      });
    }

    Mob.prototype.update = function(core) {
      var i, _results;
      this.offset = core.tile.offset;
      if (this.nextMove) {
        this.nextMove = false;
        _results = [];
        for (i in this.arr) {
          _results.push(this.move(this.arr[i]));
        }
        return _results;
      }
    };

    Mob.prototype.move = function(mob) {
      var x, y;
      x = 1 - Math.floor(Math.random() * 2);
      y = 1 - Math.floor(Math.random() * 2);
      if (this.checkBound(x, y)) {
        mob.pos.x += x;
        return mob.pos.y += y;
      }
    };

    Mob.prototype.checkBound = function(x, y) {
      return x >= 0 && x < this.bound.x && y >= 0 && y < this.bound.y;
    };

    Mob.prototype.checkVisible = function(mob) {
      return mob.pos.x >= this.offset.x && mob.pos.x < this.offset.x + 32 && mob.pos.y >= this.offset.y && mob.pos.y < this.offset.y + 32;
    };

    Mob.prototype.draw = function(context) {
      var i, _results;
      _results = [];
      for (i in this.arr) {
        if (this.checkVisible(this.arr[i])) {
          _results.push(context.drawImage(this.image, 0, 0, 16, 16, 128 + this.arr[i].pos.x * 16, this.arr[i].pos.y * 16, 16, 16));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Mob;

  })();

  Particle = (function() {
    Particle.prototype.list = [];

    Particle.prototype.snowball = {};

    Particle.prototype.nextFrame = false;

    Particle.prototype.frame = 0;

    function Particle(core) {
      var _this = this;
      this.snowball = core.tile.loadSpriteset('snowball');
      core.timers.addTimer(100, function(nextFrame) {
        _this.nextFrame = nextFrame;
        _this.nextFrame = true;
        return true;
      });
    }

    Particle.prototype.update = function() {
      var i, _i, _len, _ref, _results;
      if (this.nextFrame) {
        this.nextFrame = false;
        if (this.frame < 3) {
          this.frame++;
        } else {
          this.frame = 0;
        }
      }
      _ref = this.list;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        _results.push(this.updatePosition(this.list[i]));
      }
      return _results;
    };

    Particle.prototype.updatePosition = function(particle) {
      return console.log(article.direction);
    };

    Particle.prototype.addParticle = function(type, pos, direction) {
      return list.push({
        type: type,
        pos: {
          x: pos.x,
          y: pos.y
        },
        direction: direction
      });
    };

    Particle.prototype.draw = function(context) {
      return context.drawImage(this.snowball, 16 * this.frame, 0, 16, 16, 128, 0, 16, 16);
    };

    return Particle;

  })();

  Player = (function() {
    Player.prototype.drawpos = {};

    Player.prototype.pos = {};

    Player.prototype.dir = {
      down: 0,
      right: 1,
      up: 2,
      left: 3
    };

    Player.prototype.direction = 0;

    Player.prototype.state = 0;

    Player.prototype.frame = 0;

    Player.prototype.tile = {};

    Player.prototype.image = null;

    Player.prototype.walk = false;

    Player.prototype.nextFrame = false;

    Player.prototype.canMove = false;

    Player.prototype.canAttack = true;

    function Player(core) {
      var _this = this;
      this.drawpos = {
        x: (core.tile.viewport.width >> 1) * core.tile.tile.width,
        y: (core.tile.viewport.height >> 1) * core.tile.tile.height
      };
      this.tile = {
        width: core.tile.tile.width,
        height: core.tile.tile.height
      };
      this.pos = {
        x: 15,
        y: 15
      };
      this.state = 0;
      this.frame = 0;
      this.image = core.tile.loadSpriteset('mage');
      core.timers.addTimer(120, function(canMove) {
        _this.canMove = canMove;
        _this.canMove = true;
        return true;
      });
      core.timers.addTimer(120, function(nextFrame) {
        _this.nextFrame = nextFrame;
        _this.nextFrame = true;
        return true;
      });
    }

    Player.prototype.update = function(core) {
      this.updateAttack(core);
      this.updateMove(core);
      return this.updateFrame(core);
    };

    Player.prototype.updateFrame = function(core) {
      if (this.walk && this.nextFrame) {
        this.nextFrame = false;
        if (this.frame < 3) {
          return this.frame++;
        } else {
          return this.frame = 0;
        }
      }
    };

    Player.prototype.updateAttack = function(core) {
      var _this = this;
      if (this.canAttack === true) {
        if (this.setAttack(core.input)) {
          core.generate.spawn(core.generate.type.particle, this.pos, this.direction);
          this.canAttack = false;
          return core.timers.addTimer(1000, function(resetAttack) {
            _this.resetAttack = resetAttack;
            _this.canAttack = true;
            return false;
          });
        }
      }
    };

    Player.prototype.setAttack = function(input) {
      if (input.keys[input.action.attack]) {
        console.log('attack');
        return true;
      } else {
        return false;
      }
    };

    Player.prototype.updateMove = function(core) {
      var i, isKeydown;
      isKeydown = false;
      if (this.canMove === true) {
        for (i in this.dir) {
          if (this.setMove(core.input, i)) {
            isKeydown = true;
            this.canMove = false;
            if (this.move(core.event.collision)) {
              core.tile.updateOffset({
                x: this.pos.x - 7,
                y: this.pos.y - 7
              });
            }
          }
        }
      }
      return this.walk = isKeydown;
    };

    Player.prototype.setMove = function(input, dir) {
      if (input.keys[input.direction[dir]]) {
        this.direction = this.dir[dir];
        return true;
      }
      return false;
    };

    Player.prototype.move = function(collision) {
      var next;
      next = {
        x: this.pos.x + (this.direction === this.dir.left ? -1 : this.direction === this.dir.right ? 1 : 0),
        y: this.pos.y + (this.direction === this.dir.up ? -1 : this.direction === this.dir.down ? 1 : 0)
      };
      if (!collision(next)) {
        this.pos = next;
      }
      return true;
    };

    Player.prototype.draw = function(context) {
      return context.drawImage(this.image, this.frame * this.tile.width, this.direction * this.tile.height, this.tile.width, this.tile.height, 128 + this.drawpos.x, this.drawpos.y, this.tile.width, this.tile.height);
    };

    return Player;

  })();

  World = (function() {
    World.prototype.tile = {};

    World.prototype.size = {};

    World.prototype.arr = [];

    World.prototype.tileset = null;

    World.prototype.viewport = {};

    World.prototype.offset = {};

    function World(core) {
      this.size.x = 32;
      this.size.y = 32;
      this.prepare();
      this.tileset = core.tile.loadTileset('iceworld');
      this.viewport = {
        width: core.tile.viewport.width,
        height: core.tile.viewport.height
      };
      this.offset = {
        x: 0,
        y: 0
      };
      this.tile = {
        width: core.tile.tile.width,
        height: core.tile.tile.height
      };
    }

    World.prototype.prepare = function() {
      var i, j, x, y, _i, _results;
      this.arr = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.size.x; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (j = _j = 0, _ref1 = this.size.y; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              _results1.push(0);
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
      _results = [];
      for (i = _i = 0; _i <= 20; i = ++_i) {
        x = Math.floor(Math.random() * this.size.x);
        y = Math.floor(Math.random() * this.size.y);
        _results.push(this.arr[x][y] = 4);
      }
      return _results;
    };

    World.prototype.update = function(core) {
      this.offset = core.tile.offset;
      return core.event.updateBound(this.size);
    };

    World.prototype.draw = function(context) {
      var i, j, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.viewport.width; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (j = _j = 0, _ref1 = this.viewport.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push(this.drawTile(context, i, j, i + this.offset.x, j + this.offset.y));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    World.prototype.drawTile = function(context, x, y, i, j) {
      if (i > -1 && i < this.arr.length && j > -1 && j < this.arr[i].length) {
        return context.drawImage(this.tileset, this.arr[i][j] % this.size.x * this.tile.width, this.arr[i][j] / this.size.y * this.tile.height, this.tile.width, this.tile.height, 128 + x * this.tile.width, y * this.tile.height, this.tile.width, this.tile.height);
      }
    };

    return World;

  })();

}).call(this);
